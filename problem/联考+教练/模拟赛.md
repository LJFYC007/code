# 模拟赛
<center>Ijf007&ljf007</center>

|题目名称|树|最大公约数|游戏|序列|
|----|----|----|----|----|
|题目类型| 传统型|传统型 |传统型 |传统型|
|输入文件名|tree.in|gcd.in|game.in|sequence.in|
|输出文件名|tree.out|gcd.out|game.out|sequence.out|
|每个测试点时间限制|1s|2s|1s|1s|
|每个测试点内存限制|512MB|512MB|512MB|512MB|
|提交源程序文件名|tree.cpp|gcd.cpp|game.cpp|sequence.cpp|

|编译选项|-lm -O2 -std=c++14|
|----|----|
|测试环境|Ubuntu20.04|
|机器配置|可能是Intel(R) Core(TM) i7-10875H CPU @ 2.30GHz,内存32GB。|



## 树(tree)
<center>1s,512MB</center>
#### 题目描述

给定一棵 $n$ 个点的树，$IJF007$ 想删去这棵树的一些边。每次操作 $IJF007$ 会挑选 **原树** 两个叶子结点，满足这两个点间路径上的边均未被删除，然后删去这条路径上的所有边。 $IJF007$ 想知道最少的操作次数，但是因为他很菜，所以被迫请求你的帮助。

#### 输入格式

第一行一个整数 $n$

接下来 $n-1$ 行，每行两个数描述一条边

#### 输出格式

一行一个整数，表示最少操作次数

#### 样例输入

```
9
1 2
1 3
2 4
2 5
3 6
3 7
8 2
9 3
```

#### 样例输出

```
3
```

#### 数据范围

Subtask1(30pts)，满足 $n\leq 1000$

Subtask2(70pts)，满足 $n\leq 5\times 10^5$

## 最大公约数(gcd)
<center>2s,512MB</center>

#### 题目描述

给定 $n$ 个数。每次可以选择将一个数 +1 或 −1 。求至少多少次操作使得整个序列都是正数且全部元素的 gcd⁡>1 。


#### 输入格式

第一行三个正整数n。

第二行n个正整数。

#### 输出格式

一个整数表示最小操作次数。

#### 样例

gcd1.in
```
3
6 2 4
```
gcd1.out
```
0
```
gcd2.in
```
5
9 8 7 3 1
```
gcd2.out
```
4
```
#### 数据范围

对于$30\%$ 的数据，满足$n\le 1000$。
对于另外$30\%$ 的数据，满足$a_i\le 30000$。
对于$100\%$ 的数据，满足$1\le d<n\le 200000,1\le a_i\le 10^{12} $。

## 博弈(game)
<center>1s,512MB</center>

#### 题目描述


Alice和Bob正在玩游戏。首先，Alice构造一棵 $n$ 个节点且每个节点度数不超过 $d$ 的带节点编号的树 $T$ 。然后，Bob选择两个不同的节点 $u$ 和 $v$，并写下从 $u$ 到 $v$ 路径上的节点编号，记为序列 $a1, a2... ak$ 。最后，Ember在序列中选择一个位置 $i(1\le  i < k)$，并在以下两个操作选择一个执行：

- 翻转 $a_{i+1}... a_k$ 并将这一段加上$a_i$，操作后序列变为 $a_1, ... a_i, a_k + a_i, a_{k-1 }+ a_i, ... a_{i+1} + a_i$
- 取负 $a_{i+1}... a_k$ 并将这一段加上$a_i$，操作后序列变为 $a_1, ...a_i,- a_{i+1} + a_i,- a_{i+2} + a_i,...- a_k+a_i$。

如果最后的序列是严格单调的，则Alice获胜，否则Bob获胜。

游戏情形可以用一个元组 (T, u, v, i, op) 来描述，op为翻转或是取负取决于Bob的决策。若Alice和Bob都使用最优策略（若有多种必胜策略，任选一种执行；若必败，也任选一种执行），试统计所有可能的游戏情形的数量，并输出其取模m的结果。

#### 输入格式

一行三个正整数n,d,m。

#### 输出格式

一行一个整数表示答案模m后的结果。

#### 样例

|   input   | output     |
| ---- | ---- |
|    2 1 1000000007  |   4|
|   3 1 250   |    0  |
|   3 2 100   |  36    |
|  200 40 725 | 350 |

#### 数据范围

对于$20\%$ 的数据，满足$n\le 7$。
对于另外$20\%$ 的数据，满足$d=2$。
对于另外$20\%$ 的数据，满足$d=n-1$。
对于$100\%$ 的数据，满足$1\le d<n\le 200,1\le m \le 2\times 10^9 $。

## 序列(sequence)
<center>1s,512MB</center>
#### 题目描述

给定一个长度为 $n$ 的序列 $\{a\}$，$IJF007$ 想对这个序列进行任意打乱。我们定义一种打乱的优美度为 $\min_{i=1}^{n-1}|a_i-a_{i+1}|$ , $IJF007$ 想要找到优美度最大的那个序列，但是因为他很菜，所以被迫请求你的帮助。

#### 输入格式

第一行一个整数 $n$

第二行 $n$ 个整数表示序列 $\{a\}$

#### 输出格式

一行 $n$ 个整数表示优美度最大的那个序列

#### 样例输入

```
3
4 1 7
```

#### 样例输出

````
1 4 7
````

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\leq 10$

对于前 $30\%$ 的数据，满足 $n \leq 1000$

对于另外 $20\%$ 的数据，满足 $|a_i| \leq 10$

对于全部数据，满足 $n\leq 2\times 10^5,|a_i|\leq10^9$

