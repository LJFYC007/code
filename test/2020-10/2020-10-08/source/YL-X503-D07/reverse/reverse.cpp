/***************************************************************
	File name: reverse.cpp
	Author: ljfcnyali
	Create time: 2020年10月08日 星期四 11时38分05秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 
#define int long long
#define pii pair<int, int>
typedef long long LL;

const int maxn = 1e5 + 10;
const int Mod = 998244353;

int type, n, k, ans, fac[maxn], inv[maxn];
char s[maxn];

inline int power(int a, int b) { int r = 1; while ( b ) { if ( b & 1 ) r = r * a % Mod; a = a * a % Mod; b >>= 1; } return r; }

inline int C(int n, int m) { return n < m ? 0 : (fac[n] * inv[m] % Mod) * inv[n - m] % Mod; }

namespace Subtask1
{
    int f[1 << 23];
    inline void main()
    {
        scanf("%s", s + 1);
        int x = 0, m = 0;    
        REP(i, 1, n) if ( s[i] == '1' ) { x += 1 << i - 1; ++ m; }
        f[x] = 1;
        for ( int i = x; i >= 0; -- i ) 
        {
            if ( !f[i] ) continue ;
            int num = 0;
            REP(j, 1, n) if ( (i >> j - 1) & 1 ) ++ num;
            if ( num == m - k ) ans += f[i];
            if ( num <= m - k ) continue ;
            REP(j, 1, n)
            {
                if ( !((i >> j - 1) & 1) ) continue ;
                int now = j, x = i - (1 << j - 1); f[x] = (f[x] + f[i]) % Mod;
                while ( now + 2 <= n ) 
                {
                    ++ now; if ( (i >> now - 1) & 1 ) break ; x += (1 << now - 1);
                    ++ now; if ( !((i >> now - 1) & 1) ) break ; x -= (1 << now - 1);
                    f[x] = (f[x] + f[i]) % Mod; 
                }
            }
        }
    }
}

namespace Subtask2
{
    int f[maxn] = {1,745615823,474349650,157783954,866771321,754050977,12827918,90721369,742809337,619485903,602870105,531939121,176098212,152329568,923542628,350793140,171159002,492956976,354704294,851916133,973057368,611275142,719254420,909823695,300881566,406097368,935083420,404054247,240428589,771004672,785631611,20015619,488705979,572719309,401931868,613106605,89615382,240326281,155327767,289591726,272938552,375067680,590997204,710214284,756378406,784072174,413735249,701316520,300310523,415868876,663613190,332482638,968647922,800421330,940651473,405454078,372013352,157067689,735575920,429527216,201683836,36329646,705157770,8058543,80868181,870049591,2146040,562741997,666371710,679281255,640052352,676335116,677066750,126286159,150518888,720276243,927761614,809561487,628108860,394207966,405904067,526187873,310762830,903488510,712756306,927777719,555516684,669986435,425244357,571780347,221325174,564379345,538273906,553910289,541226821,753444380,173889797,119418065,760023358,544658138,598048000,697404600,184497032,623670583,141355713,159214314,703491607,52928163,846425642,319960016,621781911,921012137,138400021,939384358,958752225,298059649,9245259,626022372,926162363,584804114,234259666,590483009,507529494,822718363,920474973,87416834,809095565,181243655,373762106,532039024,154800848,332962352,484726286,358880484,558917643,702263669,168632835,953318311,901827723,375805900,448810879,672283223,208638612,636698041,724564523,164996448,693550730,182392998,407119258,523901041,281056452,597424628,303795573,735394781,500967701,283882320,994434856,175929014,186620947,838957566,59923617,809869905,567024697,788229987,503442230,477438213,18113564,997865714,411250813,833456040,742170701,241730923,730362248,87741866,166447252,16593297,930535017,562893421,46513065,272572771,747754636,733090460,87070992,995632656,618295736,437980824,558246655,559202662,335140417,374967169,534436782,486728840,668350476,137972447,565068029,783419227,454668452,638908105,761102691,955677976,229675900,692459751,186526385,602511277,176502119,365307259,130030693,975388126,833349738,396120267,119792223,157612559,383408652,153090414,843222398,766803846,932660181,755699544,421823332,595049411,466018540,592477761,276286667,562425144,145147831,868942465,722362525,318386840,60314884,618260978,935843236,18689617,816574299,416621738,887681547,8824399,903761440,123145328,928116330,354792532,67753993,130587085,220768573,139228977,538952595,849472355,84499854,62921215,659315160,713433995,351468303,952306764,233053163,691912357,584009562,361726389,872973014,914138479,739361862,57892259,265944861,696490917,567175252,705040836,135450661,152469035,636442284,295009176,852120509,831392452,332166658,201570394,79767635,926944197,945602376,586875401,829173354,371078822,745396052,811103049,626895088,242382708,948811487,542783473,588726208,758524741,91403487,383645807,86932309,308251837,966658272,161155165,761410594,158942267,722289038,642840766,739377965,115950704,362739367,997926238,165767177,12273244,652265783,376161755,382120645,778739121,908549278,747865800,294494722,167494695,983003272,897357206,608358120,389634252,114116821,310528947,700321535,529616468,669341074,276377052,632144796,590015148,785008874,859641818,946717474,698319690,151420630,567406127,23701893,61150866,942254222,873310535,141795665,154732095,571877038,895639312,543721107,598157635,62734841,219846356,270052522,77813328,143875214,889311846,152650212,154750872,572782978,6263720,568704530,461086287,513317092,181669712,50093038,689884866,405597633,197321214,608062662,346883494,818092952,473601748,233677970,426802368,489089277,1394581,706857443,325499708,404286811,537361282,48745106,687143295,493956304,727740024,856134852,863627625,821610520,966668985,66727789,749349740,885795181,806620048,522185256,923597558,43743248,289111214,550174017,438243799,980879653,695737214,192214310,426025845,882171809,51419126,805919818,586815316,25734273,427687694,572820401,127646728,205341543,846652363,847523741};

    inline void main()
    {
        if ( 2 * n - 1 >= Mod ) return ;        
        int num = n / 1000000;
        ans = f[num];
        REP(i, num * 1000000 + 1, n) ans = ans * (2 * i + 1) % Mod;
    }
}

namespace Subtask3
{
    const int maxn = 130;
    int f[maxn][maxn], g[maxn][maxn];

    inline void main()
    {
        int m = 3 * n;
        fac[0] = inv[0] = 1; REP(i, 1, m) fac[i] = fac[i - 1] * i % Mod;
        inv[m] = power(fac[m], Mod - 2); for ( int i = m - 1; i >= 1; -- i ) inv[i] = inv[i + 1] * (i + 1) % Mod;
        ++ n;
        REP(i, 0, n) f[i][0] = 1;
        REP(a, 1, n) 
        {
            REP(b, 0, k) REP(x, 0, a - 1) REP(y, 0, b) 
                g[a][b] = (g[a][b] + (f[x][y] * f[a - 1 - x][b - y] % Mod) * C(b, y)) % Mod;

            REP(b, 1, k) REP(i, 0, a) REP(j, 0, b - 1)
                f[a][b] = (f[a][b] + (g[i][j] * f[a - i][b - j - 1] % Mod) * C(b - 1, j)) % Mod;
        }
        ans = f[n][k];
    }
}

signed main()
{
    freopen("reverse.in", "r", stdin);
    freopen("reverse.out", "w", stdout);
    cin >> type >> n >> k;
    if ( type == 1 ) Subtask1 :: main();
    else if ( k == n + 1 ) Subtask2 :: main();
    else Subtask3 :: main();
    printf("%lld\n", (ans + Mod) % Mod);
    return 0;
}
