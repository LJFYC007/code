### 做法0

​	如果你没有注意到输出的边的顺序和平常的顺序不太一样。可以获得 0 到 100 不等的分值。

​	<del>相信大家很少会被坑读入和输出，所以这个是为了提醒大家认真阅读输入输出格式。</del>

### 做法1

![1594809652660](.\figure_1.png)

​	考虑第 $i$ 个点和第 $i - 1$ 个点之间（如果 $i = 1$那么就是 $i$ 和 $n$ 之间）的边都没有选，那么方案数是对于 $j = 1, \cdots, i - 1$，点 $j$ 连出去的红边的数量的乘积。

​	不难利用 $C$ 的二进制像图中一样进行构造。具体细节请参考下发的 80 分程序。

​	这是原来的标准做法，期望得分 80 分。

### 做法2

![1594810546035](.\figure_2.png)

​	考虑这样一个图怎么计算方案数。

​	考虑从上到下依次加入框内的点，然后加入和它相邻的边。记录选择一些边，使得不存在环，并且当前点能到达 $n$ 的方案数 $f$，以及不能到的方案数 $g$。（你需要保证加入一条当前到 $n$ 的边后所有点都能到达 $n$）。

- 如果新加入了一个点和它与上一个点相邻的边，那么有 $g' = f + g, f' = f$
- 如果加入一条与最后一个点相邻的红边，那么有 $f' = f + g, g' = g$

​	初始 $f = 1, g = 0$

​	至于如何找到一组 $f = C$ 的解。标程采用随机化，多次在 $[1, C - 1]$ 中随机一个与 $C$ 互质的数 $x$，然后检查构造出 $f = C, g = x$ 的点数和边数是否满足条件。

​	因为出题人和验题人水平有限，没能分析出这个做法的复杂度和下界，但这个做法在随机数据下运行效果良好。（题目给出的限制在随机数据下仍然比较宽松）

​	如果 std 被 hack，<del>请喷 jerome_wei </del>（相信善良的 oier 不会为了模拟赛的 20 分大动肝火）请联系 316266181@qq.com 或者 jerome_wei@qq.com。

​	如果您有更好的做法，欢迎和出题人以及验题人交流。

​	