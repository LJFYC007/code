# A (graph)

对于给出的边不连通的情况，只需要分成两个块，每次操作都在同一个块内进行，第一个块全部往第二个块连边，显然就一定合法。

对于第二档部分分：一开始第二个块内只有一个点，第一个块向第二个块连边，第一个块内的边暂时不确定方向。加入一条边时，如果在同一个块内就忽略，否则把在第一个块内的点拉到第二个块来，并钦定此时仍然是一向二连。只要最后第一个块非空就合法。合理地选择第一个点即可使得前 $\frac n2$ 条边都被忽略。

对于第三档部分分：考虑 $m$ 条边，建出最小生成树。每次拿出权值最大的边，会把树分成两个部分，在较小的部分选择第一个点。这样就可以使得另外一边的边全部被忽略。一直这样做直到只剩一个点，那么这 $n-1$ 条边除了 $\log$ 条以外全部被忽略，恰好满足 $m$ 的限制。
实现时只需要枚举第一个点选哪个即可。

# B (gcds)
考虑上值域的限制，就会稍微难处理一点，需要用合理的方法枚举这个位置选哪几个质数。

除了前后缀不变的贡献，经过这个点 $i$ 的子串有三种：$l<i,r=i$ ；$l=i,r>i$ ；$l<i<r$ 。（忽略 $l=r=i$ ）

对于前两种，只要有一个质数即可确定贡献；而第三种只和 $\gcd(a_{i-1},a_{i+1})$ 有关。

所以可以枚举 $\gcd$ 内选了哪几个，有 $2^6$ 种情况；然后分别再枚举两个质数，统计贡献。

如果卡常，可以注意到 $\gcd$ 有六个质数时，$a_{i-1},a_{i+1}$ 的质因子集合一定相等，所以此时可以直接取 $a_i=a_{i-1}$ 。这样可以让常数除以 2 。

# C (fight)

发现答案的存在性关于 $W$ 并不单调，二分是假的。

考虑从大到小枚举 $W$，就变成了每次加入一些操作。

考虑怎么判别 $W$ 是否合法。

我们把有效果的操作按照 $T_i$ 从大到小排序，设 $tmp=V_S$，遇到增幅法术就让 $tmp$ 减一，遇到削弱法术就让 $tmp$ 加一，不考虑上下界限制。

画图发现如果 $W$ 合法，那么第一次 $tmp=0$ 的时刻小于第一次 $tmp>MX$ 的时刻，第一次 $tmp=MX$ 的时刻小于第一次 $tmp<0$ 的时刻。可以通过线段树二分判别。

然后对于每一个 $V_0$ 模拟亦可。

复杂度 $O(n\log n)$。

# D (perm)

容易想到容斥。由于一个数只被 ban 掉了两个位置，容易想到把数看做边，把位置看做点，建图，会建出一些环来。

那么每个环就要求出 $f_i$ 表示选了 $i$ 条边的方案数。

选了一个边集时，特判一整个环都选了，然后方案数就是每条链的长度（点）的乘积。
`swap(V,E)` ，那么就是每条链的长度（点）加一的乘积。

长度加一可以看做这条链上任取一个点或者不取。从任意一个没有选的点处切开，

然后设 $dp_{i,j,0/1}$ 表示前 $i$ 个点选了 $j$ 个，当前这条链有没有选点，的方案数，随便转移。然后除掉没选的点的个数。

最后在外面把容斥套上即可。